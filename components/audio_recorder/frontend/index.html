<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Audio Recorder</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto",
          "Helvetica", "Arial", sans-serif;
      }
      .container {
        max-width: 600px;
        margin: 0 auto;
      }
      .controls {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
      }
      button {
        padding: 12px 24px;
        font-size: 16px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.3s;
        font-weight: 500;
      }
      #startBtn {
        background-color: #4caf50;
        color: white;
      }
      #startBtn:hover:not(:disabled) {
        background-color: #45a049;
      }
      #stopBtn {
        background-color: #f44336;
        color: white;
      }
      #stopBtn:hover:not(:disabled) {
        background-color: #da190b;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .status {
        padding: 15px;
        border-radius: 6px;
        margin-bottom: 15px;
        font-size: 14px;
      }
      .status.recording {
        background-color: #ffebee;
        color: #c62828;
        border-left: 4px solid #f44336;
      }
      .status.idle {
        background-color: #e8f5e9;
        color: #2e7d32;
        border-left: 4px solid #4caf50;
      }
      .status.error {
        background-color: #fff3e0;
        color: #e65100;
        border-left: 4px solid #ff9800;
      }
      .info {
        font-size: 12px;
        color: #666;
        margin-top: 10px;
      }
      .recording-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        background-color: #f44336;
        border-radius: 50%;
        margin-right: 8px;
        animation: pulse 1.5s ease-in-out infinite;
      }
      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.3;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="controls">
        <button id="startBtn">ğŸ¤ éŒ²éŸ³é–‹å§‹</button>
        <button id="stopBtn" disabled>â¹ï¸ éŒ²éŸ³åœæ­¢</button>
      </div>
      <div id="status" class="status idle">å¾…æ©Ÿä¸­...</div>
      <div class="info">
        <p>
          ğŸ“ éŒ²éŸ³ã¯<span id="chunkDuration"></span
          >ç§’ã”ã¨ã«è‡ªå‹•ã§ãƒãƒ£ãƒ³ã‚¯é€ä¿¡ã•ã‚Œã¾ã™
        </p>
        <p>ğŸ”´ é€ä¿¡ã•ã‚ŒãŸãƒãƒ£ãƒ³ã‚¯æ•°: <span id="chunkCount">0</span></p>
      </div>
    </div>

    <script>
      let mediaRecorder = null;
      let audioChunks = [];
      let chunkTimer = null;
      let chunkCount = 0;
      let isRecording = false;

      // Streamlitã‹ã‚‰ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å–å¾—
      const urlParams = new URLSearchParams(window.location.search);
      let chunkDuration = parseInt(urlParams.get("chunk_duration")) || 60;

      // Streamlitã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆåˆæœŸåŒ–
      function onRender(event) {
        if (event.detail.args && event.detail.args.chunk_duration) {
          chunkDuration = event.detail.args.chunk_duration;
        }
        document.getElementById("chunkDuration").textContent = chunkDuration;
      }

      // Streamlitã¸ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡
      function sendDataToStreamlit(audioData) {
        const reader = new FileReader();
        reader.onloadend = function () {
          const base64data = reader.result.split(",")[1];
          Streamlit.setComponentValue({
            audio: base64data,
            timestamp: Date.now(),
            chunk_number: chunkCount,
          });
        };
        reader.readAsDataURL(audioData);
      }

      // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
      function updateStatus(message, type = "idle") {
        const statusEl = document.getElementById("status");
        statusEl.className = `status ${type}`;
        if (type === "recording") {
          statusEl.innerHTML = `<span class="recording-indicator"></span>${message}`;
        } else {
          statusEl.textContent = message;
        }
      }

      // ãƒãƒ£ãƒ³ã‚¯ã‚’å‡¦ç†ã—ã¦é€ä¿¡
      function processChunk() {
        if (audioChunks.length > 0) {
          const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
          audioChunks = [];
          chunkCount++;
          document.getElementById("chunkCount").textContent = chunkCount;

          updateStatus(
            `éŒ²éŸ³ä¸­... (ãƒãƒ£ãƒ³ã‚¯ #${chunkCount} ã‚’é€ä¿¡ä¸­)`,
            "recording"
          );
          sendDataToStreamlit(audioBlob);
        }
      }

      // éŒ²éŸ³é–‹å§‹
      async function startRecording() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
            },
          });

          // WebMãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§éŒ²éŸ³ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶äº’æ›æ€§ãŒé«˜ã„ï¼‰
          const options = { mimeType: "audio/webm" };
          mediaRecorder = new MediaRecorder(stream, options);

          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              audioChunks.push(event.data);
            }
          };

          mediaRecorder.onstop = () => {
            // æœ€å¾Œã®ãƒãƒ£ãƒ³ã‚¯ã‚’é€ä¿¡
            processChunk();
            stream.getTracks().forEach((track) => track.stop());
          };

          mediaRecorder.start();
          isRecording = true;
          chunkCount = 0;
          document.getElementById("chunkCount").textContent = chunkCount;

          updateStatus(
            `éŒ²éŸ³ä¸­... (${chunkDuration}ç§’ã”ã¨ã«è‡ªå‹•é€ä¿¡)`,
            "recording"
          );
          document.getElementById("startBtn").disabled = true;
          document.getElementById("stopBtn").disabled = false;

          // å®šæœŸçš„ã«ãƒãƒ£ãƒ³ã‚¯ã‚’å‡¦ç†
          chunkTimer = setInterval(() => {
            if (
              isRecording &&
              mediaRecorder &&
              mediaRecorder.state === "recording"
            ) {
              // ç¾åœ¨ã®éŒ²éŸ³ã‚’ä¸€æ™‚åœæ­¢ã—ã¦ãƒãƒ£ãƒ³ã‚¯ã‚’å‡¦ç†
              mediaRecorder.stop();

              // æ–°ã—ã„MediaRecorderã‚’é–‹å§‹
              setTimeout(() => {
                if (isRecording) {
                  mediaRecorder.start();
                }
              }, 100);
            }
          }, chunkDuration * 1000);
        } catch (error) {
          console.error("éŒ²éŸ³é–‹å§‹ã‚¨ãƒ©ãƒ¼:", error);
          updateStatus("ã‚¨ãƒ©ãƒ¼: ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸ", "error");
        }
      }

      // éŒ²éŸ³åœæ­¢
      function stopRecording() {
        isRecording = false;
        if (chunkTimer) {
          clearInterval(chunkTimer);
          chunkTimer = null;
        }

        if (mediaRecorder && mediaRecorder.state !== "inactive") {
          mediaRecorder.stop();
        }

        updateStatus("éŒ²éŸ³ã‚’åœæ­¢ã—ã¾ã—ãŸ", "idle");
        document.getElementById("startBtn").disabled = false;
        document.getElementById("stopBtn").disabled = true;
      }

      // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
      document
        .getElementById("startBtn")
        .addEventListener("click", startRecording);
      document
        .getElementById("stopBtn")
        .addEventListener("click", stopRecording);

      // StreamlitåˆæœŸåŒ–
      window.addEventListener("message", onRender);
      document.getElementById("chunkDuration").textContent = chunkDuration;

      // Streamlitã«æº–å‚™å®Œäº†ã‚’é€šçŸ¥
      if (window.Streamlit) {
        Streamlit.setComponentReady();
        Streamlit.setFrameHeight(200);
      }
    </script>

    <!-- Streamlit Component API -->
    <script src="https://cdn.jsdelivr.net/npm/streamlit-component-lib@1.4.1/dist/streamlit-component-lib.js"></script>
  </body>
</html>
